(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{427:function(a,v,t){"use strict";t.r(v);var _=t(61),s=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"基础篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[a._v("#")]),a._v(" 基础篇")]),a._v(" "),t("h2",{attrs:{id:"面向对象与面向过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象与面向过程"}},[a._v("#")]),a._v(" 面向对象与面向过程")]),a._v(" "),t("p",[a._v("什么是面向对象？什么是面向过程？")]),a._v(" "),t("p",[a._v("对象：指一个具体的事物被抽取出来的本质。例如汽车，都有轮子方向盘。")]),a._v(" "),t("p",[a._v("过程：就是一个个步骤，每个步骤用函数实现")]),a._v(" "),t("h2",{attrs:{id:"封装、继承、多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装、继承、多态"}},[a._v("#")]),a._v(" 封装、继承、多态")]),a._v(" "),t("h3",{attrs:{id:"什么是多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是多态"}},[a._v("#")]),a._v(" 什么是多态")]),a._v(" "),t("p",[a._v("Java中的多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。")]),a._v(" "),t("p",[a._v("Java中多态其实是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：")]),a._v(" "),t("ul",[t("li",[a._v("有类继承或者接口实现")]),a._v(" "),t("li",[a._v("子类要重写父类的方法")]),a._v(" "),t("li",[a._v("父类的引用指向子类的对象")])]),a._v(" "),t("h3",{attrs:{id:"静态多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态多态"}},[a._v("#")]),a._v(" 静态多态")]),a._v(" "),t("p",[a._v("上面我们说的多态，是一种运行期的概念。另外，还有一种说法，认为多态还分为动态多态和静态多态。")]),a._v(" "),t("p",[a._v("上面提到的那种动态绑定认为是动态多态，因为只有在运行期才能知道真正调用的是哪个类的方法。")]),a._v(" "),t("p",[a._v("很多人认为，还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法。")]),a._v(" "),t("p",[a._v("结合2.1章节，我们介绍过的重载和重写的相关概念，我们再来总结下重载和重写这两个概念：")]),a._v(" "),t("p",[a._v("1、重载是一个编译期概念、重写是一个运行期概念。")]),a._v(" "),t("p",[a._v("2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。")]),a._v(" "),t("p",[a._v("3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。")]),a._v(" "),t("p",[a._v("4、Java中的方法重写是Java多态（子类型）的实现方式。而Java中的方法重写其实是特设多态的一种实现方式。")])])}),[],!1,null,null,null);v.default=s.exports}}]);